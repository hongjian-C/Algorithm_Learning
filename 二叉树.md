# 二叉树

## 树

![img](https://static001.geekbang.org/resource/image/40/1e/4094a733986073fedb6b9d03f877d71e.jpg?wh=1142*565)

![img](https://static001.geekbang.org/resource/image/50/b4/50f89510ad1f7570791dd12f4e9adeb4.jpg?wh=1142*570)

## 二叉树（binary tree）

每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点

**满二叉树**：叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点

**完全二叉树**：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大



### 如何储存一棵二叉树

#### 链式存储法

![img](https://static001.geekbang.org/resource/image/12/8e/12cd11b2432ed7c4dfc9a2053cb70b8e.jpg?wh=1142*734)

每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针

#### 顺序存储法

我们把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置

![img](https://static001.geekbang.org/resource/image/14/30/14eaa820cb89a17a7303e8847a412330.jpg?wh=1142*604)

如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式



### 二叉树的遍历

三种经典方法

#### 前序遍历

对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。

#### 中序遍历

对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。

#### 后序遍历

对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。

![img](https://static001.geekbang.org/resource/image/ab/16/ab103822e75b5b15c615b68560cb2416.jpg?wh=1142*582)

**实际上，二叉树的前、中、后序遍历就是一个递归的过程**

`前序遍历的递推公式：`
`preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)`

`中序遍历的递推公式：`
`inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)`

`后序遍历的递推公式：`
`postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r`



## 二叉查找树

二叉查找树的特殊结构：

在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值



### 二叉查找树的查找操作

先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。

![img](https://static001.geekbang.org/resource/image/96/2a/96b3d86ed9b7c4f399e8357ceed0db2a.jpg?wh=1142*616)





### 二叉查找树的插入操作

如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。

![img](https://static001.geekbang.org/resource/image/da/c5/daa9fb557726ee6183c5b80222cfc5c5.jpg?wh=1142*602)



### 二叉查找树的删除操作

#### 没有子节点

如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null

#### 只有一个子节点

如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了

#### 有两个子节点

如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点



**中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度为O(n)**



### 支持重复数据的二叉查找树

在实际的软件开发中，我们在二叉查找树中存储的，是一个包含很多字段的对象。我们利用对象的某个字段作为键值（key）来构建二叉查找树。我们把对象中的其他字段叫作卫星数据。



**方法一**：

通过链表和支持动态扩容的数组等数据结构，把值相同的数据存储在同一个节点上



**方法二**：

每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。

![img](https://static001.geekbang.org/resource/image/3f/5f/3f59a40e3d927f567022918d89590a5f.jpg?wh=1142*555)

当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来

![img](https://static001.geekbang.org/resource/image/fb/ff/fb7b320efd59a05469d6d6fcf0c98eff.jpg?wh=1142*577)



### 二叉查找树的时间复杂度分析

最糟：退化为链表 O(n)

理想：平衡二叉查找数 O(logn)



# 题目

## 合并二叉树

1. 确定递归函数的参数和返回值

   参数：两个二叉树的根节点

   返回值：合并二叉树的根节点

2. 确定终止条件

   ```c++
   if (t1 == NULL) return t2; // 如果t1为空，合并之后就应该是t2
   if (t2 == NULL) return t1; // 如果t2为空，合并之后就应该是t1
   
   ```

3. 确定单层递归逻辑

   把两棵树的元素加在一起

   ```c++
   t1->val += t2->val;
   ```

   t1的左子树为合并t1 t2 左子树

   t1的右子树为合并t1 t2 右子树

   

4. 返回t1