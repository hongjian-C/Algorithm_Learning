# 动态规划

### 动态规划特点

#### 重叠子问题

动态规划的子问题是有重叠的，即各个子问题中包含重复的更小子问题。若使用暴力法穷举，求解这些相同子问题会产生大量的重复计算，效率低下。

动态规划在第一次求解某子问题时，会将子问题的解保存；后续遇到重叠子问题时，则直接通过查表获取解，保证每个**独立子问题只被计算一次**，从而降低算法的时间复杂度。



看例子：**斐波那契数列**

动态规划：

![Picture3.png](https://pic.leetcode-cn.com/1635075778-EeBEoS-Picture3.png)

代码：

**方法一：**

`// 求第 n 个斐波那契数`
`int fibonacci(int n) {`
    `if (n == 0) return 0;          // 若求 f(0) 则直接返回 0`
    `vector<int> dp(n + 1, 0);      // 初始化 dp 列表`
    `dp[1] = 1;                     // 初始化 f(0), f(1)`
    `for (int i = 2; i <= n; i++) { // 状态转移求取 f(2), f(3), ..., f(n)` 
        `dp[i] = dp[i - 1] + dp[i - 2];`
    `}`
    `return dp[n];                  // 返回 f(n)`
`}`



**方法二**

`// 求第 n 个斐波那契数`
`int fibonacci(int n) {`
    `if (n == 0) return 0;           // 若求 f(0) 则直接返回 0`
    `int a = 0, b = 1;               // 初始化 f(0), f(1)`
    `for (int i = 2; i <= n; i++) {  // 状态转移求取 f(2), f(3), ..., f(n)` 
        `int tmp = a;`
        `a = b;`
        `b = tmp + b;`
    `}`
    `return b;                       // 返回 f(n)`
`}`



#### **最优子结构**

如果一个问题的最优解可以由其子问题的最优解组合构成，并且这些子问题可以独立求解，那么称此问题具有最优子结构。

动态规划从基础问题的解开始，不断迭代组合、选择子问题的最优解，最终得到原问题最优解。

**蛋糕最高售价：**

