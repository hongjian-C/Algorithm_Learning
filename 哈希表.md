# 哈希表

**18-20 哈希表，21-22 哈希算法**



散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来



## **散列思想**![img](https://static001.geekbang.org/resource/image/92/73/92c89a57e21f49d2f14f4424343a2773.jpg?wh=1142*744)

通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。

### **散列函数** 

hash(key)

key为元素的键值

**构造散列函数(设计要求)**

1. 散列函数计算得到的散列值是一个非负整数
2. 如果 key1 = key2，那 hash(key1) == hash(key2)
3. 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)

第三点涉及散列冲突问题

### **散列冲突**

**解决方法**

1. 开放寻址法

   如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入

   探测新的位置的方法：**线性探测**

   **插入**
   
   ![img](https://static001.geekbang.org/resource/image/5c/d5/5c31a3127cbc00f0c63409bbe1fbd0d5.jpg?wh=1142*530)
   
   当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。
   
   不需要扩容 复杂度为O(1)
   
   **查找**
   
   ![img](https://static001.geekbang.org/resource/image/91/ff/9126b0d33476777e7371b96e676e90ff.jpg?wh=1142*1522)
   
   **删除** 
   
   将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。
   
   ![img](https://static001.geekbang.org/resource/image/fe/1d/fe7482ba09670cbe05a9dfe4dd49bd1d.jpg?wh=1142*641)
   
   线性探测最坏情况复杂度为O(n)
   
   **二次探测**：步长变为二次方
   
   **双重散列**：使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。
   
   **装载因子**：表示空位的多少 = 填入表中的元素个数/散列表的长度。 装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降

2. 链表法

   ![img](https://static001.geekbang.org/resource/image/a4/7f/a4b77d593e4cb76acb2b0689294ec17f.jpg?wh=1142*640)

   散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。



## 如何设计散列函数

散列函数不能太复杂

散列函数生成的值要尽可能随机并且均匀分布

装载因子过大：数据扩容（数据搬移操作）

散列表的大小变了，数据的存储位置也变了，所以我们需要通过散列函数重新计算每个数据的存储位置

![img](https://static001.geekbang.org/resource/image/67/43/67d12e07a7d673a9c1d14354ad029443.jpg?wh=1142*756)

### 如何避免低效扩容

装载因子达到阈值时，只申请新空间，并不将老数据搬移到新列表中；当有新数据插入时，将新数据插入新散列表，并从老散列表中拿出一个数据放入新散列表中。



查询：先从新散列表中查找，没有再去老散列表中查找



插入一个数据的时间复杂度为O(1)



## 散列表和链表一起使用

### LRU缓存淘汰算法

一个缓存系统主要有三个操作

1. 添加数据
2. 删除数据
3. 查找数据

都涉及查找，将三个操作的时间复杂度从O(n)降为O(1)

![img](https://static001.geekbang.org/resource/image/ea/6e/eaefd5f4028cc7d4cfbb56b24ce8ae6e.jpg?wh=1142*726)

我们使用双向链表存储数据，链表中的每个结点处理存储数据（data）、前驱指针（prev）、后继指针（next）之外，还新增了一个特殊的字段 hnext



因为我们的散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是刚刚我们提到的双向链表，另一个链是散列表中的拉链。前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中