# 排序

![img](https://static001.geekbang.org/resource/image/fb/cd/fb8394a588b12ff6695cfd664afb17cd.jpg?wh=1142*704)

排序算法需要考虑的情况：

1. 最好，最坏，平均时间复杂度
2. 时间复杂度的系数，常数，低阶（针对小规模数据）
3. 比较次数和交换次数

### 原地排序

？排序算法稳定性

稳定排序算法可以保持相同的两个元素，在排序之后，前后顺序不变

#### 冒泡排序

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

![img](https://static001.geekbang.org/resource/image/40/e9/4038f64f47975ab9f519e4f739e464e9.jpg?wh=1142*741)

![img](https://static001.geekbang.org/resource/image/a9/e6/a9783a3b13c11a5e064c5306c261e8e6.jpg?wh=1142*679)

#### 插入排序

![img](https://static001.geekbang.org/resource/image/7b/a6/7b257e179787c633d2bd171a764171a6.jpg?wh=1142*699)

这是一个动态排序的过程，即动态地往有序集合中添加数据，我们可以通过这种方法保持集合中的数据一直有序。而对于一组静态数据，我们也可以借鉴上面讲的插入方法，来进行排序，于是就有了插入排序算法。



步骤：

1. 将数组分为**已排序区间**和**未排序区间**

2. 初始已排序区间只有一个元素，在已排序区间中找到合适的插入位置插

   

包含：**元素的比较**和**元素的移动**



#### 选择排序

![img](https://static001.geekbang.org/resource/image/32/1d/32371475a0b08f0db9861d102474181d.jpg?wh=1142*856)

区分已排序区间和未排序区间，每次从未排序区间中选择最小的元素，将其放到已排序区间的末尾



### 适合大规模数据排序

#### 归并排序

我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。

![img](https://static001.geekbang.org/resource/image/db/2b/db7f892d3355ef74da9cd64aa926dc2b.jpg?wh=1142*914)

归并使用**分治思想**，分治是一种解决问题的思想，递归是一种编程技巧

递推公式：

merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))

q = (P+r)/2

终止条件：

p >= r 不用再继续分解

![img](https://static001.geekbang.org/resource/image/95/2f/95897ade4f7ad5d10af057b1d144a22f.jpg?wh=1142*856)

申请一个临时数组 tmp，大小与 A[p...r]相同。我们用两个游标 i 和 j，分别指向 A[p...q]和 A[q+1...r]的第一个元素。比较这两个元素 A[i]和 A[j]，如果 A[i]<=A[j]，我们就把 A[i]放入到临时数组 tmp，并且 i 后移一位，否则将 A[j]放入到数组 tmp，j 后移一位。继续上述比较过程，直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。最后再把临时数组 tmp 中的数据拷贝到原数组 A[p...r]中。



**递归的时间复杂度**

a的子问题为b,c

求解a的时间是T(a)，b，c为T(b), T(c)

对于归并排序：

T(n) = 2*T(n/2) + n = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n ...... = **2^k * T(n/2^k) + k * n**

 n/2^k=1

k=log2n

T(n)=Cn+nlog2n

时间复杂度是 O(nlogn)

归并排序不是原地排序，需要调用额外的内存空间

空间复杂度为O(n)



#### 快速排序

如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。

遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。

![img](https://static001.geekbang.org/resource/image/4d/81/4d892c3a2e08a17f16097d07ea088a81.jpg?wh=1142*615)

对A[p...r]的原地完成分区操作

![img](https://static001.geekbang.org/resource/image/08/e7/086002d67995e4769473b3f50dd96de7.jpg?wh=1142*859)

快排和归并排序对比

![img](https://static001.geekbang.org/resource/image/aa/05/aa03ae570dace416127c9ccf9db8ac05.jpg?wh=1142*757)

**快排是一种原地 不稳定的排序算法**



### 排序算法的应用场景

#### 桶排序

核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。



时间复杂度为O(n)

**桶排序比较适合用在外部排序中**。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。



#### 计数排序

与桶排序不同的地方在于桶的粒度

![img](https://static001.geekbang.org/resource/image/1d/84/1d730cb17249f8e92ef5cab53ae65784.jpg?wh=1142*1522)

计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。



#### 基数排序

基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。

![img](https://static001.geekbang.org/resource/image/df/0c/df0cdbb73bd19a2d69a52c54d8b9fc0c.jpg?wh=1142*511)



### 排序优化

![img](https://static001.geekbang.org/resource/image/1f/fd/1f6ef7e0a5365d6e9d68f0ccc71755fd.jpg?wh=1142*698)