# 链表

#### 缓存淘汰策略

先进先出 First In, First Out (FIFO）

最少使用策略 Least Frequently Used （LFU)

最近最少使用策略 Least Recently Used （LRU)

#### 使用链表实现LRU淘汰策略

![img](https://static001.geekbang.org/resource/image/d5/cd/d5d5bee4be28326ba3c28373808a62cd.jpg?wh=1142*699)

链表不需要一块连续的存储空间，通过指针将一组零散的内存块串联起来适用。

##### 单链表：

![img](https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg?wh=1142*399)

**结点：** 内存块 data

记录下个结点的指针叫做**后继指针next**

第一个结点：头结点 记录链表的基位置

最后一个结点：尾结点 指向**NULL**



**链表支持数据查找、插入和删除：**

![img](https://static001.geekbang.org/resource/image/45/17/452e943788bdeea462d364389bd08a17.jpg?wh=1142*650)

随机访问链表的第k个元素，需要遍历，复杂度为O(n)



##### 循环链表：

循环链表时一种特殊的单链表

![img](https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg?wh=1142*399)

##### 双向链表：

![img](https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg?wh=1142*399)

它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。

虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。

**删除操作**：

1. 删除结点中“值等于某个给定值”的结点
2. 删除给定指针指向的结点：双向链表不需要遍历

**用空间换时间**

对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。

##### 双向循环链表：

![img](https://static001.geekbang.org/resource/image/d1/91/d1665043b283ecdf79b157cfc9e5ed91.jpg?wh=1142*500)

#### 数组链表对比：

![img](https://static001.geekbang.org/resource/image/4f/68/4f63e92598ec2551069a0eef69db7168.jpg?wh=1142*449)

数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。

# 链表代码技巧

1. 理解指针的含义 

   p->next=q：p 结点中的 next 指针存储了 q 结点的内存地址

   p->next=p->next->next：p 结点的 next 指针存储了 p 结点的下下一个结点的内存地址

2. 警惕指针丢失和内存泄露：插入结点时，一定要注意操作顺序；删除链表结点时也要注意手动释放内存空间。

3. 利用哨兵简化实现难度：

   针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理，但是这样的代码不简洁

   引入**哨兵结点**：不管链表是不是空，head指针都会指向哨兵结点，这种有哨兵结点的链表叫带头链表。哨兵结点是不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。应用于插入排序、归并排序、动态规划中

   ![img](https://static001.geekbang.org/resource/image/7d/c7/7d22d9428bdbba96bfe388fe1e3368c7.jpg?wh=1142*382)

4. 重点留意边界条件处理

   如果链表为空时，代码是否能正常工作？如果链表只包含一个结点时，代码是否能正常工作？如果链表只包含两个结点时，代码是否能正常工作？代码逻辑在处理头结点和尾结点的时候，是否能正常工作？